[
  {
    "objectID": "posts/Pancake Sorting/index.html",
    "href": "posts/Pancake Sorting/index.html",
    "title": "Pancake Sorting",
    "section": "",
    "text": "Problem Source: Leetcode"
  },
  {
    "objectID": "posts/Pancake Sorting/index.html#problem-description",
    "href": "posts/Pancake Sorting/index.html#problem-description",
    "title": "Pancake Sorting",
    "section": "Problem Description",
    "text": "Problem Description\nGiven an array of integers arr, sort the array by performing a series of pancake flips.\nIn one pancake flip we do the following steps:\n\nChoose an integer k where 1 &lt;= k &lt;= arr.length.\nReverse the sub-array arr[0…k-1] (0-indexed).\n\nFor example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4] after the pancake flip at k = 3.\nReturn an array of the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct.\nConstraints:\n\n1 &lt;= arr.length &lt;= 100\n1 &lt;= arr[i] &lt;= arr.length\nAll integers in arr are unique (i.e. arr is a permutation of the integers from 1 to arr.length)\n\n\ntests\n\ndef test(fn):\n    value = [3,2,4,1]\n    expected = [1,2,3,4]\n    ans, actual = fn(value)\n    print(f\"Input: {value} | Answer: {ans}\")\n    assert actual == expected \n\n    value = [1,2,3]\n    expected = [1,2,3]\n    ans, actual = fn(value)\n    print(f\"Input: {value} |  Answer: {ans}\")\n    assert actual == expected"
  },
  {
    "objectID": "posts/Pancake Sorting/index.html#solutions",
    "href": "posts/Pancake Sorting/index.html#solutions",
    "title": "Pancake Sorting",
    "section": "Solutions",
    "text": "Solutions\n\nfrom typing import List\n\ndef reverse(l, n):\n    for i in range(n//2): \n        # insplace swaps means go thorugh 1/2 the list\n        l[i], l[n-i-1] = l[n-i-1], l[i]\n\n    \ndef pancakeSort(arr: List[int]) -&gt; List[int]:\n    swap_points = []\n    for value_to_sort in range(len(arr),1,-1): # if n-1 elements are correct, then n elements are correct, so don't check the smallest value (1)\n        current_location = arr.index(value_to_sort)+1\n        if value_to_sort == current_location: \n            # If value already in correct position continue\n            continue\n        if current_location != 1: # If value is in front, this step isn't needed\n            # If not, flip to get desired value in front\n            reverse(arr, current_location)\n            swap_points.append(current_location)\n        # flip to get value in final position\n        reverse(arr,value_to_sort)\n        swap_points.append(value_to_sort)\n    return swap_points, arr\n\ntest(pancakeSort)\n\nInput: [1, 2, 3, 4] | Answer: [3, 4, 2, 3, 2]\nInput: [1, 2, 3] |  Answer: []"
  },
  {
    "objectID": "posts/Palindrome Number/index.html",
    "href": "posts/Palindrome Number/index.html",
    "title": "Palindrome Number",
    "section": "",
    "text": "Problem Source: Leetcode"
  },
  {
    "objectID": "posts/Palindrome Number/index.html#problem-description",
    "href": "posts/Palindrome Number/index.html#problem-description",
    "title": "Palindrome Number",
    "section": "Problem Description",
    "text": "Problem Description\nGiven an integer x, return true if x is a palindrome, and false otherwise. You cannot convert to string.\n\ntests\n\ndef test(fn):\n    value = 121\n    expected = True\n    actual = fn(value)\n    assert actual == expected \n\n    value = -121\n    expected = False\n    actual = fn(value)\n    assert actual == expected \n\n    value = 10\n    expected = False\n    actual = fn(value)\n    assert actual == expected \n\n    value = 12321\n    expected = True\n    actual = fn(value)\n    assert actual == expected \n\n    value = 123214231\n    expected = False\n    actual = fn(value)\n    assert actual == expected"
  },
  {
    "objectID": "posts/Palindrome Number/index.html#solutions",
    "href": "posts/Palindrome Number/index.html#solutions",
    "title": "Palindrome Number",
    "section": "Solutions",
    "text": "Solutions\n\nString Index\nThe first thought is that we could cast to a string then loop halfway through the string to verify the first and laft halves are the same.\n\ndef isPalindrome(x: int) -&gt; bool:\n    x = str(x)\n    for i in range(len(x)//2):\n        first, last = x[i], x[-(i+1)]\n        if first != last: return False\n    return True\n\ntest(isPalindrome)\n\n\n\nMath\nCould you solve it without converting the integer to a string?\n\ndef isPalindrome(x: int) -&gt; bool:\n    if x &lt; 0: # A negative sign means not a palindrome\n        return False \n    if (x != 0) and (x % 10 == 0): # Int has no leading zeros, so if it ends with 0 it's not a palindrome\n        return False  \n\n    numberHalf = 0\n    while x &gt; numberHalf: # Stop once halfway\n        # Add the rightmost number from x to number half\n        numberHalf = int(numberHalf * 10 + x % 10)\n        # Drop the rightmost number on X\n        x//= 10\n\n    # If odd length drop the right most as that is the center number\n    return x == numberHalf or x == numberHalf//10 \n\ntest(isPalindrome)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Structures & Algorithms",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nTitle\n\n\nDescription\n\n\nCategories\n\n\n\n\n\n\nPancake Sorting\n\n\nSort a list using pancake flips\n\n\nArray, Two Pointers, Greedy, Sorting\n\n\n\n\nPalindrome Number\n\n\nFind indices of two numbers that add up to a target number\n\n\nmath\n\n\n\n\nTwo Sum\n\n\nDetermine if an integer is a palindrome\n\n\narray, hash table\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Two Sum/index.html",
    "href": "posts/Two Sum/index.html",
    "title": "Two Sum",
    "section": "",
    "text": "Problem Source: Leetcode"
  },
  {
    "objectID": "posts/Two Sum/index.html#problem-description",
    "href": "posts/Two Sum/index.html#problem-description",
    "title": "Two Sum",
    "section": "Problem Description",
    "text": "Problem Description\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\n\ntests\n\ndef test(fn):\n    target = 9\n    nums = [2,7,11,15]\n    expected = [0,1]\n    actual = fn(nums, target)\n    assert sorted(actual) == expected \n\n    target = 6\n    nums = [3,2,4]\n    expected = [1,2]\n    actual = fn(nums, target)\n    assert sorted(actual) == expected \n\n    target = 6\n    nums = [3,3]\n    expected = [0,1]\n    actual = fn(nums, target)\n    assert sorted(actual) == expected"
  },
  {
    "objectID": "posts/Two Sum/index.html#solutions",
    "href": "posts/Two Sum/index.html#solutions",
    "title": "Two Sum",
    "section": "Solutions",
    "text": "Solutions\n\nBrute Force O(n^2)\nThe way to brute force this problem would be to try every possible combination of 2 indices until one solves the problem. This would mean a loop in a loop, or complexity.\n\nfrom typing import List\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    for index1, num1 in enumerate(nums):\n        desired_num = target - num1\n        for index2, num2 in enumerate(nums):\n            if (num2 == desired_num) and (index1 != index2):\n                return [index1, index2]\n\ntest(twoSum)\n\n\n\nHash Map O(n)\nInstead of trying every possible combination we can calculate the other number we need, and do a lookup to see if we have seen that number we need. By doing this we only need 1 loop.\n\nfrom typing import List\ndef solution(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}\n    for i,num in enumerate(nums):\n        need = target - num\n        if need in hashmap:\n            return [i,hashmap[need]]\n        hashmap[num] = i\n\ntest(twoSum)"
  }
]