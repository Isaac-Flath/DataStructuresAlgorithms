{
  "hash": "daa147b7618a3b3297ff80892e2d45cf",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Encode and Decode Strings\"\nauthor: \"Isaac Flath\"\ndate: \"2024-02-12\"\ncategories: [array, string]\ndescription: \"Create a reversable encoding of a list of strings to a string\"\n---\n\n>Problem Source:  Leetcode\n\n## Problem Description\n\nDesign an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.\n\nMachine 1 (sender) has the function:\n```\nstring encode(vector<string> strs) {\n  // ... your code\n  return encoded_string;\n}\n```\n\nMachine 2 (receiver) has the function:\n```\nvector<string> decode(string s) {\n  //... your code\n  return strs;\n}\n```\nSo Machine 1 does:\n\n```\nstring encoded_string = encode(strs);\n```\nand Machine 2 does:\n```\nvector<string> strs2 = decode(encoded_string);\n```\n\n`strs2` in Machine 2 should be the same as `strs` in Machine 1.\n\nImplement `encode` and `decode` methods.\n\nYou are not allowed to solve the problem using any serialize methods (such as `eval`).\n\n**Constraints:**\n\n+ 1 <= strs.length <= 200\n+ 0 <= strs[i].length <= 200\n+ strs[i] contains any possible characters out of 256 valid ASCII characters.\n \n**Follow up:** Could you write a generalized algorithm to work on any possible set of characters?\n\n### tests\n\n::: {#95e039c9 .cell execution_count=1}\n``` {.python .cell-code}\ndef test(fn):\n    codec = fn()\n    \n    expected = [\"Hello\",\"World\"]\n    expected_str = '5#Hello5#World'\n    actual_str = codec.encode(expected)\n    assert actual_str == expected_str\n    actual = codec.decode(actual_str)\n    assert actual == expected\n\n    expected = [\"\"]\n    expected_str = '0#'\n    actual_str = codec.encode(expected)\n    assert actual_str == expected_str\n    actual = codec.decode(actual_str)\n    assert actual == expected\n```\n:::\n\n\n## Solution\n\n+ Time Complexity: `O(n)`\n+ Space Complexity: `O(1)`\n\n::: {#51c63e50 .cell execution_count=2}\n``` {.python .cell-code}\nfrom typing import List\nclass Codec:\n    def encode(self, strs: List[str]) -> str:\n        \"\"\"Encodes a list of strings to a single string.\n        \"\"\"\n        encoded_str = ''\n        for s in strs:\n            encoded_str += str(len(s)) + '#' + s\n        return encoded_str\n\n    def decode(self, s: str) -> List[str]:\n        \"\"\"Decodes a single string to a list of strings.\n        \"\"\"\n        i,l = 0,0\n\n        out = []\n        while i < len(s):\n            if s[i] != '#':\n                l = l * 10 + int(s[i])\n                i += 1\n            else:\n                out.append(s[i+1:i+1+l])\n                i = i + 1 + l\n                l = 0\n        return out\ntest(Codec)\n```\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}