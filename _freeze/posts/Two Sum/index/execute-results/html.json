{
  "hash": "ae6922b99943d827dce7f5f91ccdd74c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Two Sum\"\nauthor: \"Isaac Flath\"\ndate: \"2024-01-28\"\ncategories: [array, Hash Table]\ndescription: \"Find indices of two numbers that add up to a target number\"\n---\n\n>Problem Source:  Leetcode\n\n## Problem Description\n\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n### tests\n\n::: {#eab10d7d .cell execution_count=1}\n``` {.python .cell-code}\ndef test(fn):\n    target = 9\n    nums = [2,7,11,15]\n    expected = [0,1]\n    actual = fn(nums, target)\n    assert sorted(actual) == expected \n\n    target = 6\n    nums = [3,2,4]\n    expected = [1,2]\n    actual = fn(nums, target)\n    assert sorted(actual) == expected \n\n    target = 6\n    nums = [3,3]\n    expected = [0,1]\n    actual = fn(nums, target)\n    assert sorted(actual) == expected \n```\n:::\n\n\n## Solutions\n\n### Brute Force `O(n^2)`\n\nThe way to brute force this problem would be to try every possible combination of 2 indices until one solves the problem.  This would mean a loop in a loop, or  complexity.\n\n::: {#ce629fe6 .cell execution_count=2}\n``` {.python .cell-code}\nfrom typing import List\ndef twoSum(nums: List[int], target: int) -> List[int]:\n    for index1, num1 in enumerate(nums):\n        desired_num = target - num1\n        for index2, num2 in enumerate(nums):\n            if (num2 == desired_num) and (index1 != index2):\n                return [index1, index2]\n\ntest(twoSum)\n```\n:::\n\n\n### Hash Map `O(n)`\n\nInstead of trying every possible combination we can calculate the other number we need, and do a lookup to see if we have seen that number we need.  By doing this we only need 1 loop.\n\n::: {#c5583652 .cell execution_count=3}\n``` {.python .cell-code}\nfrom typing import List\ndef solution(nums: List[int], target: int) -> List[int]:\n    hashmap = {}\n    for i,num in enumerate(nums):\n        need = target - num\n        if need in hashmap:\n            return [i,hashmap[need]]\n        hashmap[num] = i\n\ntest(twoSum)\n```\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}