{
  "hash": "b5554619d92e6d4b65b20b369416ec6f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Pancake Sorting\"\nauthor: \"Isaac Flath\"\ndate: \"2024-01-30\"\ncategories: [array, two pointers, greedy, sorting]\ndescription: \"Sort a list using pancake flips\"\n---\n\n>Problem Source:  Leetcode\n\n## Problem Description\n\nGiven an array of integers `arr`, sort the array by performing a series of pancake flips.\n\nIn one pancake flip we do the following steps:\n\n1. Choose an integer k where 1 <= k <= arr.length.\n1. Reverse the sub-array arr[0...k-1] (0-indexed).\n\nFor example, if `arr = [3,2,1,4]` and we performed a pancake flip choosing `k = 3`, we reverse the sub-array `[3,2,1]`, so `arr = [1,2,3,4]` after the pancake flip at `k = 3`.\n\nReturn an array of the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within `10 * arr.length` flips will be judged as correct.\n\n**Constraints:**\n\n+ 1 <= arr.length <= 100\n+ 1 <= arr[i] <= arr.length\n+ All integers in arr are unique (i.e. arr is a permutation of the integers from 1 to arr.length)\n\n### tests\n\n::: {#50e00faa .cell execution_count=1}\n``` {.python .cell-code}\ndef test(fn):\n    value = [3,2,4,1]\n    expected = [1,2,3,4]\n    ans, actual = fn(value)\n    assert actual == expected \n\n    value = [1,2,3]\n    expected = [1,2,3]\n    ans, actual = fn(value)\n    assert actual == expected \n```\n:::\n\n\n## Solution \n\n+ Time Complexity: `O(n^2)`\n+ Space Complexity: `O(n)`\n\n::: {#4050db6a .cell execution_count=2}\n``` {.python .cell-code}\nfrom typing import List\n\ndef reverse(l, n):\n    for i in range(n//2): \n        # inplace swaps means go through 1/2 the list portion we want to swap\n        l[i], l[n-i-1] = l[n-i-1], l[i]\n\n    \ndef pancakeSort(arr: List[int]) -> List[int]:\n    swap_points = []\n    for value_to_sort in range(len(arr),1,-1): # if n-1 elements are correct, then n elements are correct, so don't check the smallest value (1)\n        current_location = arr.index(value_to_sort)+1\n        if value_to_sort == current_location: \n            # If value already in correct position continue\n            continue\n        if current_location != 1: # If value is in front, this step isn't needed\n            # If not, flip to get desired value in front\n            reverse(arr, current_location)\n            swap_points.append(current_location)\n        # flip to get value in final position\n        reverse(arr,value_to_sort)\n        swap_points.append(value_to_sort)\n    return swap_points, arr\n\ntest(pancakeSort)\n```\n:::\n\n\n",
    "supporting": [
      "Pancake Sorting_files"
    ],
    "filters": [],
    "includes": {}
  }
}